
const os = require('os');
const IS_WIN = os.platform() === 'win32';

const KindToRequiresNameMap = {
    xsuaa: 'auth',
    'hana-cloud': 'db',
    hana: 'db',
    destinations: 'destinations',
    connectivity: 'connectivity',
    'audit-log': 'audit-log',
    'enterprise-messaging': 'messaging',
    'enterprise-messaging-amqp': 'messaging',
    'enterprise-messaging-http': 'messaging',
    'enterprise-messaging-shared': 'messaging'
}

const PreferredKinds = [
    'hana-cloud',
    'xsuaa'
];

function getRequiresNameFromKind(service, kind) {
    const requiresName = KindToRequiresNameMap[kind];
    if (!requiresName) throw new Error(`Unknown CDS service name for service "${service}". Please specify as argument for "cds bind".`)
    return requiresName;
}

/**
 * Determine kind value for services based on VCAP binding
 * information in the configuration.
 */
function determineKinds(services) {
    const vcapServices = {}

    // Build VCAP_SERVICES
    for (const service of services) {
        service.kindCandidates = [ ]

        const { vcap = {} } = service.binding || {};
        let { label, type } = vcap;
        type = type || label;
        if (!type) continue;

        if (!vcapServices[type]) vcapServices[type] = [];
        vcapServices[type].push({ credentials: { dummy: 'dummy' }, ...vcap, service });
    }

// Auto configure services based on VCAP_SERVICES

    const cds = require('../cds');
    const env = cds.env.for('cds', process.cwd());

    if (!env._find_credentials_for_required_service) {
        throwError `Please provide a service kind or update @sap/cds version to use the kind detection.`;
    }

    function findKindFor(kind, service) {
        const vcapService = env._find_credentials_for_required_service(kind, service, vcapServices);
        if (!vcapService) return;
        if (!Object.values(requires).find( require => require !== service && require.kind == kind ))
            vcapService.service.kindCandidates.push(kind);
    }

    const requires = env.requires.kinds || {};
    for (const kind of Object.keys(requires)) {
        const requireService = requires[kind];
        findKindFor(kind, requireService);
        findKindFor(kind, { kind });
    }

    // Check if one "kind" per service was found
    for (const service of services) {
        const preferredKind = service.kindCandidates.find( kind => PreferredKinds.indexOf(kind) >= 0);
        if (preferredKind) {
            service.kind = preferredKind;
        } if (service.kindCandidates.length === 1) {
            service.kind = service.kindCandidates[0];
        }

        delete service.kindCandidates;
    }
}

function execAndExit(options, command, ...args) {
    const { spawnSync } = require('child_process');
    // use shell with Windows only; without output is not visible and some commands cannot be run
    const result = spawnSync(command, args, { stdio: 'inherit', shell: IS_WIN, ...options });
    process.exit(result.status);
}

async function checkIsJavaProject(projectPath) {
    const { constants, promises: fsp } = require('fs');
    const path = require('path');
    const pomXmlPath = path.join(projectPath, 'pom.xml');
    try {
        await fsp.access(pomXmlPath, constants.F_OK);
        return true;
    } catch (err) {
        return false;
    }
}


/**
 *
 * @param {string} msg
 * @returns {never}
 */
 function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}


const PLATFORM_TYPES = {
    'cf': 'Cloud Foundry',
    'k8s': 'Kubernetes'
}

function platformText(binding) {
    return PLATFORM_TYPES[binding.type] || throwError(`Unexpected binding type "${binding.type}"`);
}

function bindingText(binding, highlight = t => t) {
    switch (binding.type) {
        case 'cf':
            return `service ${highlight(binding.instance)} key ${highlight(binding.key)}`
        case 'k8s':
            if (binding.name) {
                return `service binding ${highlight(binding.name)}`
            } else {
                return `secret ${highlight(binding.secret)}`
            }
        default:
            throwError();
    }
}

module.exports = {
    getRequiresNameFromKind,
    determineKinds,
    execAndExit,
    checkIsJavaProject,
    throwError,
    platformText,
    bindingText
}
