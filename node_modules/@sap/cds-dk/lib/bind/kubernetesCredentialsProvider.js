const cp = require('child_process');
const os = require('os');
const util = require('util');
const yaml = require("@sap/cds-foss")("yaml");
const { exec } = require('../util/exec');
const https = require('https')

const axios = require('axios');
const { URL } = require('url');

const execFile = util.promisify(cp.execFile);
const IS_WIN = os.platform() === 'win32';

class KubernetesCredentialsProvider {

    constructor() {
        this.logger = console;
    }

    setLogger(logger) {
        this.logger = logger;
    }

    async _kubectlRead(...args) {
        this.logger.debug(`_kubectlRead: kubectl ${args.join(" ")}`);

        const result = await execFile("kubectl", args, {
            shell: IS_WIN,
            stdio: ['inherit', 'pipe', 'inherit'],
        });

        return result.stdout.toString().trim();
    }


    async _kubectlConfig() {
        const configString = await this._kubectlRead('config', 'view', '--raw');
        const config = yaml.parse(configString);

        const currentContextName = config["current-context"];
        if (!currentContextName) throw new Error(`No current context in kubectl config.`);
        const currentContextEntry = config.contexts && config.contexts.find( entry => entry.name === currentContextName && entry.context && entry.context.cluster && entry.context.user );
        if (!currentContextEntry) throw new Error(`Current context not found in kubectl config.`);
        const currentContext = currentContextEntry.context;
        const clusterEntry = config.clusters && config.clusters.find( entry => entry.name === currentContext.cluster && entry.cluster && entry.cluster.server );
        if (!currentContextEntry) throw new Error(`Cluster ${currentContext.cluster} not found in kubectl config.`);
        const cluster = clusterEntry.cluster;
        const userEntry = config.users && config.users.find( entry => entry.name === currentContext.user && entry.user);
        if (!userEntry) throw new Error(`User ${currentContext.user} not found in kubectl config.`);
        const user = userEntry.user;
        let token;
        if (user.token) {
            token = user.token;
        } else if (user.exec) {
            const resultJson = await exec({result: 'stdout'}, user.exec.command, ...user.exec.args);
            const result = JSON.parse(resultJson);
            token = result.status && result.status.token;
        } else {
            throwError `Unsupported authentication method for kubectl context ${currentContextName}`;
        }

        if (!token) throwError `kubectl authentication failed for kubectl context ${currentContextName}`;

        return {
            url: cluster.server,
            httpsAgent: cluster['certificate-authority-data'] && new https.Agent({
                ca: Buffer.from(cluster['certificate-authority-data'], 'base64').toString()
            }),
            namespace: currentContext.namespace || 'default',
            token
        }
    }

    async init() {
        this.config = await this._kubectlConfig();
    }

    async _req(urlPath) {

        const url = new URL(urlPath, this.config.url);
        this.logger.debug(`_req: ${url.toString()}`);

        const result = await axios.get(url.toString(), {
            validateStatus: status => status === 200 || status === 404,
            headers: {
                authorization: `Bearer ${this.config.token}`
            },
            httpsAgent: this.config.httpsAgent
        });

        if (result.status === 200) {
            return result.data;
        } else {
            return null
        }
    }


    async resolve(name, binding) {
        if (!this.initPromise) {
            this.initPromise = this.init();
        }
        await this.initPromise;

        let {cluster, namespace, name: bindingName, secret } = binding;
        let instance;
        let secretOrBindingResource = 'Secret';

        if (!namespace) namespace = this.config.namespace;
        if (cluster && cluster !== this.config.url) throw new Error(`Current Kubernetes cluster "${this.config.url}" different than Kubernetes cluster "${cluster}" for service binding "${name}".`);

        if (bindingName) {
            const bindingResource = await this._req(`/apis/services.cloud.sap.com/v1/namespaces/${encodeURIComponent(namespace)}/servicebindings/${encodeURIComponent(bindingName)}`);
            if (bindingResource === null) {
                // Fallback to secret instead of service binding;
                secret = bindingName;
                bindingName = undefined;
                secretOrBindingResource = 'Service Binding or Secret';
            } else {
                secret = bindingResource.spec.secretName || throwError();
                instance = bindingResource.spec.serviceInstanceName || throwError();
            }
        }

        const secretResource = await this._req(`/api/v1/namespaces/${encodeURIComponent(namespace)}/secrets/${encodeURIComponent(secret)}`);
        if (secretResource === null) throwError(`${secretOrBindingResource} '${secret}' not found.`);

        const serviceBinding = readBinding(name, secretResource);
        const { credentials } = serviceBinding;
        const vcap = {...serviceBinding, credentials: undefined}

        const resolvedBinding = {
            binding: {
                type: "k8s",
                name: bindingName,
                cluster: this.config.url,
                instance,
                namespace,
                secret: secret,
                resolved: true,
                vcap
            },
            credentials
        };

        return resolvedBinding;
    }

}

function readBinding(name, secret) {
    const { data } = secret;
    const properties = {};
    for (const name in data) {
        const value = Buffer.from(data[name], "base64").toString()
        properties[name] = value;
    }

    let parseBinding
    try {
        // eslint-disable-next-line
        parseBinding = require('@sap/cds/lib/env/serviceBindings').parseBinding;
    } catch (error) {
        //
    }
    if (!parseBinding) throwError `Please update your @sap/cds version for Kubernetes support`

    return parseBinding('/', name, properties);
}


/**
 *
 * @param {string} msg
 * @returns {never}
 */
function throwError(msg = 'Internal Error') {
    throw new Error(msg);
}

module.exports = new KubernetesCredentialsProvider();
