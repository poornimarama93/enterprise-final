const path = require('path')
const ProjectReader = require('../../util/projectReader')
const { mergeYAML } = require('../../util/merge')
const { copy } = require('../../../cds').utils

module.exports = class DestinationsTemplate extends require('../templateBase') {
    constructor(projectPath, generator) {
        super(projectPath, generator, __dirname)
        this.projectReader = new ProjectReader(projectPath)
    }

    static hasFacet(env) {
        const kinds = { odata: 1, 'odata-v2': 1, 'odata-v4': 1, rest: 1 }
        return Object.entries(env.requires).some(([service, require]) => !kinds[service] && kinds[require.kind])
    }

    async run() {
        await this.runDependentMerging()
    }

    async runDependentMerging() {
        const projectDescriptor = await this.projectReader.read(this.options)
        const { hasHelm, hasDestination, hasHtml5Repo } = projectDescriptor.cap

        if (hasHelm) {
            //const env = await this.getEnv()
            const binding = hasDestination && { srv: { bindings: { destination: { serviceInstanceName: 'destinations' }}}}
            const html5Binding = hasHtml5Repo && { html5_apps_deployer: { bindings: { destination: { serviceInstanceName: 'destination' }}}}

            await mergeYAML(
                path.join(this.projectPath, 'chart', 'values.yaml'),
                {
                    ...binding,
                    ...html5Binding,
                    destination: {
                        serviceOfferingName: 'destination',
                        servicePlanName: 'lite',
                        parameters: {
                            version: '1.0.0',
                            ...(hasHtml5Repo) && { HTML5Runtime_enabled: true }
                        }
                    }
                },
                null, { forceOverwrite: true }
            )
            await copy(path.join(__dirname, 'files', 'destination.yaml'), path.join(this.projectPath, 'chart', 'templates', 'destination.yaml'))
        }
    }
}
