const cds = require('../../../cds')
const { path, copy, exists } = cds.utils
const ProjectReader = require('../../util/projectReader')
const { mergeJSON, mergeYAML, sortDependencies } = require('../../util/merge')
const {
  srvNode, srvJava, // Server
  mtxSidecar, // Additional Modules
  saasRegistry, serviceManager, xsuaa, // BTP Services
  providedMtxAPI, srvAPI, providedMtxSidecarAPI, requiredMtxSidecarAPI // APIs
} = require('../_merging/registry-mta');

module.exports = class MultitenancyTemplate extends require('../templateBase') {
  constructor(projectPath, generator) {
    super(projectPath, generator, __dirname)
    this.projectReader = new ProjectReader(projectPath)
  }

  static hasFacet(env, projectPath, options) {
    // REVISIT: Check if this can be simplified
    return options?.add?.has('mtx') || options?.add?.has('multitenancy') ||
           !!env.requires?.multitenancy || !!env.requires?.db?.multiTenant ||
           this.isJava && exists(path.join(projectPath, 'mtx', 'sidecar')) || false
  }

  async run() {
    const projectDescriptor = await this.projectReader.read(this.options)
    const { for: forProfile, isNodejs, isJava } = projectDescriptor.cap
    if (isNodejs) {
      const packageJSONPath = path.join(this.projectPath, 'package.json')
      const cdsTemplateFile = forProfile ? 'cds.package.json.hbs' : 'cds.package.json'
      await mergeJSON(packageJSONPath, path.join(__dirname, 'files', cdsTemplateFile), projectDescriptor)
      await mergeJSON(packageJSONPath, path.join(__dirname, 'files', 'dependencies.package.json'))
      await sortDependencies(packageJSONPath)
    } else if (isJava) {
      const cdsrcJSONPath = path.join(this.projectPath, '.cdsrc.json')
      await mergeJSON(cdsrcJSONPath, path.join(__dirname, 'files', 'java', '.cdsrc.json'))
      await copy(path.join(__dirname, 'files', 'java', 'package.json'), path.join(this.projectPath, 'mtx', 'sidecar', 'package.json'))
    }
    await this.runDependentMerging()
  }

  async runDependentMerging() {
    const projectDescriptor = await this.projectReader.read()
    const { isNodejs, isJava, hasMta, hasHelm, hasApprouter, hasXsuaa, hasHana } = projectDescriptor.cap

    if (hasMta) {
      const modules = isNodejs ? [srvNode] : [srvJava, mtxSidecar]
      const srv = isNodejs ? srvNode : srvJava
      const services = [saasRegistry]
      if (hasXsuaa) services.push(xsuaa)
      const apis = isNodejs ? [providedMtxAPI] : [srvAPI, providedMtxAPI, providedMtxSidecarAPI, requiredMtxSidecarAPI]
      const additions = [...modules, ...services, ...apis]

      const overwrites = hasXsuaa ? [{ item: [xsuaa, 'parameters.config.tenant-mode'], withValue: 'shared'}] : []

      const relationships =  [{
        insert: [saasRegistry, 'name'],
        into: [srv, 'requires', 'name']
      }]
      if (isJava) {
        if (hasXsuaa) {
          relationships.push({
            insert: [xsuaa, 'name'],
            into: [mtxSidecar, 'requires', 'name']
          })
        }
        if (hasHana) {
          relationships.push({
              insert: [serviceManager, 'name'],
              into: [mtxSidecar, 'requires', 'name'],
          })
        }
      }

      const templateMtaPath = path.join(__dirname, `files`, `mta.yaml.hbs`)
      const mtaPath = path.join(this.projectPath, 'mta.yaml')
      const mergingRules = { additions, overwrites, relationships }
      await mergeYAML(mtaPath, templateMtaPath, projectDescriptor, mergingRules)
    }

    if (hasHelm) {
      await mergeYAML(
        path.join(this.projectPath, 'chart', 'values.yaml'),
        {
          xsuaa: {
            serviceOfferingName: 'saas-registry',
            servicePlanName: 'application'
          }
        },
        null, { forceOverwrite: true }
      )
      //if (hasXsuaa) { // REVISIT: Can we get rid of this dependency?
        await copy(
          path.join(__dirname, 'files', 'xsuaa.yaml'),
          path.join(this.projectPath, 'chart', 'templates', 'xsuaa.yaml')
        )
      //}
      await copy(
        path.join(__dirname, 'files', 'saas-registry.yaml'),
        path.join(this.projectPath, 'chart', 'templates', 'saas-registry.yaml')
      )
    }

    if (hasApprouter) {
      const ApprouterTemplate = require(`../approuter`)
      const template = new ApprouterTemplate(this.projectPath, this.generator)
      await template.runDependentMerging()
    }

    if (hasHana) {
      const HanaTemplate = require(`../hana`)
      const template = new HanaTemplate(this.projectPath, this.generator)
      await template.runDependentMerging()
    }

    if (hasXsuaa) {
      await mergeJSON(
        path.join(this.projectPath, 'xs-security.json'),
        path.join(__dirname, 'files', 'xs-security.json.hbs'),
        projectDescriptor,
        {
          additions: [{
            ref: 'scope-mtcallback',
            in: 'scopes',
            where: [{ property: 'name', isEqualTo: '$XSAPPNAME.mtcallback' }],
          }, {
            ref: 'scope-subscriber',
            in: 'scopes',
            where: [{ property: 'name', isEqualTo: '$XSAPPNAME.cds.Subscriber' }],
          }]
        }
      )
    }

    if (hasXsuaa && hasHelm) {
      // REVISIT: Shared xs-security.json location for Helm and MTA?
      await copy(
        path.join(this.projectPath, 'xs-security.json'),
        path.join(this.projectPath, 'chart', 'xs-security.json')
      )
    }
  }
}
