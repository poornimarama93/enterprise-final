// Each db has some changes that it can and cannot represent, or that cause problems only on that specific db
// In this file, we define rules for each db-dialect to detect and act on these cases.

const { forEach } = require("../utils/objectUtils");
const { isPersistedAsTable } = require('../model/csnUtils');

function isKey(element) {
  return element.key;
}

module.exports = {
  sqlite: getFilterObject(
    'sqlite', 
    (extend, name, element, error) => {
      if(isKey(element)) { // Key must not be extended
        error(null, ['definitions', extend, 'elements', name], {id: name, name: 'sqlite'}, "Added element $(ID) is a primary key change and will not work with $(NAME)")
      }
    },
    (migrate, name, migration, change, error) => {
      const newIsKey = isKey(migration.new);
      const oldIsKey = isKey(migration.old);
      if((newIsKey || oldIsKey) && oldIsKey !== newIsKey) { // Turned into key or key was removed
        error(null, ['definitions', migrate, 'elements', name], {id: name, name: 'sqlite'}, "Changed element $(ID) is a primary key change and will not work with $(NAME)")
      } else { // Ignore simple migrations
        delete change[name];
      }
    })
}

function getFilterObject(dialect, extensionCallback, migrationCallback) {
  return {
        // will be called with a simple Array.forEach
    extension: ({ elements, extend }, error) => {
      forEach(elements, (name, element) => {
        extensionCallback(extend, name, element, error);
      });
    },
    // will be called with a Array.map, as we need to filter "change" for SQLite
    migration: ({ change, migrate, remove }, error) => {
      forEach(remove, (name) => {
        error(null, ['definitions', migrate, 'elements', name], {}, "Dropping elements is not supported")
      });

      forEach(change, (name, migration) => {
        if(migration.new.type !== migration.old.type && typeChangeIsNotCompatible(dialect, migration.old.type, migration.new.type)) {
          error(null, ['definitions', migrate, 'elements', name], { id: name, name: migration.old.type, type: migration.new.type }, "Changed element $(ID) is a lossy type change from $(NAME) to $(TYPE) and is not supported")
        } else if(migration.new.length < migration.old.length) {
          error(null, ['definitions', migrate, 'elements', name], { id: name }, "Changed element $(ID) is a length reduction and is not supported")
        } else {
          migrationCallback(migrate, name, migration, change, error);
        }

        // TODO: precision/scale growth
      });
    },
    deletion: ([artifactName, artifact ], error) => {
      if(isPersistedAsTable(artifact))
        error(null, ['definitions', artifactName], "Dropping tables is not supported");
    }
  }
}

const baseMatrix = {
  // Integer types
  'cds.hana.tinyint':['cds.UInt8', 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64'],
  'cds.UInt8': ['cds.hana.tinyint', 'cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64'],
  'cds.Int16': ['cds.hana.smallint', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64'],
  'cds.hana.smallint':['cds.Int16', 'cds.Int32', 'cds.Integer', 'cds.Int64', 'cds.Integer64'],
  'cds.Int32': ['cds.Integer', 'cds.Int64', 'cds.Integer64'],
  'cds.Integer': ['cds.Int32', 'cds.Int64', 'cds.Integer64'],
  'cds.Integer64': ['cds.Int64'],
  'cds.Int64': ['cds.Integer64']
}

const allowedTypeChanges = {
  'sqlite': baseMatrix
};

function typeChangeIsNotCompatible(dialect, before, after) {
  if(allowedTypeChanges[dialect])
    return allowedTypeChanges[dialect][before]?.indexOf(after) === -1;
  return true;
}