// using from '../deployment-service'; //> IMPORTANT: don't add this as it will cause services loaded twice

@protocol: 'rest'
@(requires: ['cds.Subscriber', 'mtcallback', 'internal-user'])
@(path:'/-/cds/saas-provisioning')
service cds.xt.SaasProvisioningService @(impl:'@sap/cds-mtxs/srv/cf/saas-provisioning-service.js') {

    /* SaaS Provisioning */

    @open
    @cds.persistence.skip
    entity tenant {
        key subscribedTenantId : String;       // ID of the subscription tenant
            subscribedSubaccountId : UUID;     // ID of subscription subaccount
            subscribedSubdomain : String(256); // subdomain of subscription subaccount.
            subscriptionAppName : String(256); // The application name of the main subscribed application.
            eventType: String(64);             // "CREATE/UPDATE". Indicates if callback called with new subscription (CREATE) or as part of update dependencies (UPDATE)
    }

    function dependencies() returns array of { xsappname: String };
}

/* Multitenancy */
extend service cds.xt.SaasProvisioningService with {
    @open type UpgradeOptions {}
    @open type UpgradeResults {}

    @open action upgrade(tenants: Array of String, options: UpgradeOptions) returns UpgradeResults;

    // keep until Java has adopted new API
    @deprecated @open action upgradeAll (tenants: Array of String, options: UpgradeOptions) returns UpgradeResults;

    // internal API - not so nice to model the request as parameter :( -> pass only headers?
    function getAppUrl(subscriptionPayload: {}, subscriptionHeaders: {}) returns String;

}

/* Jobs */
extend service cds.xt.SaasProvisioningService with {
    @cds.persistence.skip
    @readonly
    entity jobs {
        key jobID: String;
            processId: Integer;
            status:    {};
            result:    {};
            error:     {};
    }

    function diagnoseJobs() returns {};
}
