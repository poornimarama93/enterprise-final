const cds = require('@sap/cds/lib')
const LOG = cds.log('mtx')
const { submit, getStatus, diagnose } = require('../jobs/async')
const { asyncPool } = require('../jobs/parallel')
const SaasRegistryUtil = require('./saas-registry-util')
const Tenants = 'cds.xt.Tenants'

// TODO: Implement/validate scope/tenant ID checks
const DEFAULT_APP_URL = 'tenant successfully subscribed - no application url provided'

module.exports = class SaasProvisioningService extends cds.ApplicationService {

  async init() {
    // TODO: Support UPDATE event type for saas-registry
    //this.on('UPDATE', 'tenant', ({data}) => data?.eventType === 'UPDATE' ? this.update : this.create)
    this.on('UPDATE', 'tenant', this.create)
    this.on('READ', 'tenant', this.read)
    this.on('DELETE', 'tenant', this.delete)
    this.on('dependencies', this.getDependencies)
    this.on('getAppUrl', this.determineAppUrl)
    this.on('succeeded', this.succeeded)
    this.on('failed', this.failed)
    this.on('upgrade', this.update)
    this.on('upgradeAll', this.updateAll)
    this.on('GET', 'jobs', this.getJobStatus)
    this.on('diagnoseJobs', this.diagnoseJob)

    await super.init() // ensure to call super.init()
  }

  _options(data) {
    const _ = data?._application_?.sap ? { hdi: { create: data._application_.sap['service-manager'] } } : data._
    return {...data.options, _ }
  }

  async _subscribe(context) {
    const tenant = this._getSubscribedTenant(context)
    LOG.info(`Subscribing tenant ${tenant}`)

    try {
      const deploymentService = await cds.connect.to('cds.xt.DeploymentService')
      const tx = deploymentService.tx(context)
      await tx.subscribe(tenant, context.data, this._options(context.data))
      LOG.info(`Successfully subscribed tenant ${tenant}`)
      await this.emit('succeeded', { task: 'subscribe', result: await this._getAppUrl(context.data, context.headers) })
    } catch (error) {
      await this.emit('failed', { task: 'subscribe', result: error })
      throw error
    }
  }

  async _updateAll(tenants, context) {
    LOG.info(`Upgrading tenants: ${JSON.stringify(tenants)}`)
    // REVISIT: One job for the upgradeAll or one job per tenant?
    const deploymentService = await cds.connect.to('cds.xt.DeploymentService')
    const tx = deploymentService.tx(context)
    const { poolSize = 1 } = cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}
    try {
      await asyncPool(poolSize, tenants, t => tx.upgrade(t))
      await this.emit('succeeded', { task: 'upgrade' })
    } catch (error) {
      await this.emit('failed', { task: 'upgrade', result: error })
      throw error
    }
  }

  async _unsubscribe(context) {
    const tenant = this._getSubscribedTenant(context)
    LOG.info(`Unsubscribing tenant ${tenant}`)

    // REVISIT: What if there's no subdomain (currently silently ignored)? (e.g. tenant was onboarded via DeploymentService)
    const { metadata } = (await cds.tx({ tenant: this._t0 }, tx =>
      tx.run(SELECT.one.from(Tenants, { ID: tenant }, tenant => { tenant.metadata }))
    )) ?? {}

    const ds = await cds.connect.to('cds.xt.DeploymentService')
    const tx = ds.tx(context)
    try {
      await tx.unsubscribe(tenant, { metadata: JSON.parse(metadata ?? '{}') })
      LOG.info(`Successfully unsubscribed tenant ${tenant}`)
      await this.emit('succeeded', { task: 'unsubscribe' })
    } catch (error) {
      if (error.statusCode === 404) LOG.info(`Tenant ${tenant} is currently not subscribed`)
      else {
        await this.emit('failed', { task: 'unsubscribe', result: error })
        throw error
      }
    }
  }

  get _t0() {
    return cds.env.requires.multitenancy.t0 ?? 't0'
  }


  getJobStatus(context) {
    const { jobID } = context.data
    const { identityzoneid } =
      cds.env.requires.multitenancy?.credentials ??
      cds.env.requires['cds.xt.SaasProvisioningService']?.credentials ??
      cds.env.requires.auth?.credentials ?? {}
    // TODO discuss if additional check for identityzone would make sense (if present)
    return getStatus(jobID, context.tenant, context.user.is('internal-user') || context.tenant && context.tenant === identityzoneid)
  }

  diagnoseJob() {
    return diagnose()
  }

  async determineAppUrl(context) {
    return SaasRegistryUtil.getAppUrlFromHeaders(context.data.subscriptionHeaders)
        ?? SaasRegistryUtil.getAppUrlFromEnv(context.data.subscriptionPayload)
        ?? DEFAULT_APP_URL
  }

  async _getAppUrl(subscriptionPayload, subscriptionHeaders) {
    const sps = await cds.connect.to('cds.xt.SaasProvisioningService')
    return sps.getAppUrl(subscriptionPayload, subscriptionHeaders)
  }

  async create(context) {
    LOG.debug('Received subscription request', context.data)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context._.req)

    if (isSync) {
        await this._subscribe(context)
        return this._getAppUrl(context.data, context.headers)
    }

    const tenant = this._getSubscribedTenant(context)
    return submit(tenant, this._subscribe.bind(this), context, { context })
  }

  _getSubscribedTenant(context) {
    const { data: { subscribedTenantId }, params } = context
    return (params && params[0]?.subscribedTenantId) ?? subscribedTenantId
  }

  async read(context) { // TODO check params for get
    const tenantId = this._getSubscribedTenant(context)
    if (tenantId) {
      const tenant = await cds.tx({ tenant: this._t0 }, tx =>
        tx.run(SELECT.one.from(Tenants, { ID: tenantId }, tenant => { tenant.metadata }))
      )
      if (!tenant) cds.error(`Tenant ${tenantId} not found`, { status: 404 })
      return JSON.parse(tenant.metadata)
    }
    return (await cds.tx({ tenant: this._t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID, tenant.metadata }))
    )).map(tenant => JSON.parse(tenant.metadata))
  }

  async delete(context) {
    LOG.debug('Received unsubscription request', context.data)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context._.req)

    if (isSync) {
        return this._unsubscribe(context)
    }

    const tenant = this._getSubscribedTenant(context)
    return submit(tenant, this._unsubscribe.bind(this), context, { context })
  }

  async getDependencies() {
    return cds.env.requires['cds.xt.SaasProvisioningService']?.dependencies?.map(d => ({ xsappname: d })) ?? []
  }

  async updateAll(context) {
    LOG.warn(`updateAll is deprecated. Use update instead`)
    if (!context.data?.tenants) context.data.tenants = ['*']
    return this.update(context)
  }

  async update(context) {
    if (!context.data?.tenants?.length) return
    const tenantList = context.data.tenants.includes('*') ? undefined : context.data.tenants
    const tenants = tenantList ?? (await cds.tx({ tenant: this._t0 }, tx =>
      tx.run(SELECT.from(Tenants, tenant => { tenant.ID }))
    )).map(({ ID }) => ID)
    const { isSync } = SaasRegistryUtil.getCallbackUrlsFromHeaders(context._.req)
    if (isSync) return this._updateAll(tenants, context)
    // REVISIT: Which tenant ID here?
    // use tenant from context if available
    // use constant if not (dwc use case)
    return submit(context.tenant ?? 'provider', this._updateAll.bind(this), [tenants, context], { context })
  }

  async succeeded(event) {
    await this._sendCallback('SUCCEEDED', 'Succeeded', event.data.result)
  }

  async failed(event) {
    await this._sendCallback('FAILED', 'Failed', event.data.result)
  }

  async _sendCallback(status, message, subscriptionUrl) {
    const originalRequest = cds.context._.req
    const {
      isSync, isInternalCallback, saasCallbackUrlPath, callbackUrl, noCallback
    } = SaasRegistryUtil.getCallbackUrlsFromHeaders(originalRequest)
    if (!isSync && !noCallback) {
        /// TODO evaluate params for new rest adapter
        const tenant = this._getSubscribedTenant(originalRequest.body)

        const payload = { status, message, subscriptionUrl }

        // additional payload for internal callback (java)
        if (isInternalCallback) {
            Object.assign(payload, {
                saasRequestPayload: originalRequest.body,
                saasCallbackUrl: saasCallbackUrlPath
            })
        }

        LOG.debug(`Send callback to ${callbackUrl}`)
        try {
            await SaasRegistryUtil.sendResult(callbackUrl, tenant, payload)
        } catch (error) {
            LOG.error(error);
        }
    }
  }
}


// workaround for HANA Service Manager:
if (!cds.env.requires.multitenancy) cds.env.requires.multitenancy = true
