const { URL } = require('url')
const axios = require('axios')
const cds = require('@sap/cds/lib')//, { axios } = cds.utils // REVISIT: Use axios helper in @sap/cds?
const LOG = cds.log('mtx')

module.exports = class SaasRegistryUtil {

    static get SUCCEEDED() {
        return "SUCCEEDED"
    }

    static get FAILED() {
        return "FAILED"
    }

    // TODO find out purpose of the authHeader parameter - intended to be set with internal mtx callback? Is auth header set in that case?
    static async sendResult(callbackUrl, tenant, payload, authHeader) {
        const { status, message, subscriptionUrl, saasCallbackUrl, saasRequestPayload } = payload
        const data = { subscriptionUrl, message, status }

        // call to internal application callback (java use case) -> piggyback original SaaS payload
        if (saasCallbackUrl) {
            Object.assign(data, { tenant, saasCallbackUrl, saasRequestPayload })
        }

        let headers
        try {
            const authorization = authHeader ?? `Bearer ${await SaasRegistryUtil._getAuthToken()}`
            headers = { authorization }
        } catch(error) {
            if (!authHeader) {
                LOG.warn('No authentication header for callback')
            }
            // REVISIT: Why only throw error if saasCallbackUrl is undefined? E.g. if _getAuthToken fails
            if (!saasCallbackUrl) { // direct call to saas registry needs auth header
                throw error
            }
        }

        LOG.info('Sending result callback request to', callbackUrl)
        LOG.debug('Sending result:', data)

        // REVISIT: internal call - necessary?
        if (saasCallbackUrl) {
            Object.assign(headers, { status_callback: saasCallbackUrl })
        }

        try {
            return await axios(callbackUrl, { method: 'PUT', headers, data })
        } catch (error) {
            // REVISIT: Why not just throw the error?
            LOG.error(error.message)
            throw new Error('Error sending result callback to saas-registry')
        }
    }

    static async _getAuthToken() {
        // TODO: find out why compat does not work
        const credentials = cds.env.requires?.multitenancy?.credentials
        // const credentials = typeof credentialsFromEnv === 'object'
        //         ? credentialsFromEnv
        //         : process.env.VCAP_SERVICES ? JSON.parse(process.env.VCAP_SERVICES)['saas-registry'][0].credentials : {}
        // TODO: throw cds.error?
        // TODO: Better error messages. 1. Diagnose -> 2. Support Proposal (i.e. tell how to fix the error)

        if (!credentials) {
            cds.error('No saas-registry credentials found', { status: 401 })
        }

        const { clientid, clientsecret, url } = credentials

        if (!clientid || !clientsecret || !url) {
            cds.error('No saas-registry credentials available from the application environment.', { status: 401 })
        }

        try {
            LOG.info(`Getting saas-registry auth token from ${url}`)
            const { data: { access_token } } = await axios(`${url}/oauth/token`, {
                method: 'POST',
                auth: {
                    username: clientid,
                    password: clientsecret,
                },
                headers: {
                    'Content-Type': 'application/json'
                },
                params: {
                    grant_type: 'client_credentials',
                    response_type: 'token'
                },
            })
            if (!access_token) {
                cds.error('Could not get saas-registry token: token is empty', { status: 401 })
            }
            return access_token
        } catch (error) {
            LOG.error(error.message) // TODO: Needed here? Is this the default behavior of `cds.error`?
            // Should we swallow the original error message?
            cds.error('Could not get auth token for saas-registry', { status: 401 })
        }
    }

    static getCallbackUrlsFromHeaders(req) {
        class CallbackHeaders {
            constructor(headers = {}) {
                const { prefer, status_callback } = headers
                if (prefer?.includes('respond-async')) {
                    this.respondAsync = true
                }
                if (status_callback) {
                    const { saas_registry_url } =
                      cds.env.requires.multitenancy?.credentials ??
                      cds.env.requires['cds.xt.SaasProvisioningService']?.credentials ?? {}
                    this.saasCallbackUrlPath = status_callback
                    this.saasCallbackUrl = new URL(status_callback, saas_registry_url).toString()
                    const { mtx_status_callback } = headers
                    this.mtxCallbackUrl = mtx_status_callback
                }
            }
            get callbackUrl() {
                return this.mtxCallbackUrl ?? this.saasCallbackUrl
            }
            get isSync() {
                return !this.saasCallbackUrl && !this.respondAsync
            }
            get isInternalCallback() {
                return !!this.mtxCallbackUrl
            }
            get noCallback() {
                return this.respondAsync && !this.callbackUrl
            }
        }
        return new CallbackHeaders(req.headers)
    }

    static getAppUrlFromHeaders(headers) {
        return headers?.application_url
    }

    static get SUBDOMAIN_PLACEHOLDER() {
        return 'tenant_subdomain'
    }

    static get SUBSCRIPTION_URL() {
        return 'SUBSCRIPTION_URL'
    }

    static getAppUrlFromEnv(subscriptionPayload) {

        const { subscribedSubdomain } = subscriptionPayload

        const urlFromEnv = process.env[SaasRegistryUtil.SUBSCRIPTION_URL]

        return urlFromEnv ? urlFromEnv.replace(`\${${SaasRegistryUtil.SUBDOMAIN_PLACEHOLDER}}`, subscribedSubdomain) : undefined
    }
}
