const cds = require('@sap/cds/lib'), { fs, path, tar, rimraf } = cds.utils
const linter = require('./linter')

const activate = require('./activate')
const { collectFiles, getCompilerError } = require('../../lib/utils')

const TEMP_DIR = fs.realpathSync(require('os').tmpdir())
const LOG = cds.log('mtx')

const _compileProject = async function (extension) {
  const root = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    await tar.xvz(extension).to(root)
    
    let extCsn
    try { extCsn = await cds.utils.read(path.join(root, 'extension.csn')) } 
    catch(e) { if (e.code !== 'ENOENT') throw e }

    let bundles    
    try { bundles = await cds.utils.read(path.join(root, 'i18n', 'i18n.json')) } 
    catch(e) { if (e.code !== 'ENOENT') throw e }

    return { extCsn: extCsn && JSON.parse(extCsn), bundles }
  } finally {
    rimraf (root)
  }
}

const base = async function (req) {
  const cdsFiles = cds.resolve('*').filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const csvObj = await cds.deploy.resources()
  const csvFiles = Object.keys(csvObj).filter(f => f.startsWith(cds.root) && !f.includes('node_modules'))
  const i18nFiles = collectFiles(cds.root, ['.properties'])
  if (req._.res) req._.res.set('content-type', 'application/octet-stream; charset=binary')
  return tar.cz([...cdsFiles, ...csvFiles, ...i18nFiles])
}

const pull = async function (req) {
  LOG.info(`pulling latest model for tenant '${req.tenant}'`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  const csn = await mps.getCsn({
    tenant: req.tenant,
    toggles: Object.keys(cds.context.features || {}), // with all enabled feature extensions
    base: true, // without any custom extensions
    flavor: 'xtended'
  })

  req._.res?.set('content-type', 'application/octet-stream; charset=binary')

  const temp = await fs.promises.mkdtemp(`${TEMP_DIR}${path.sep}extension-`)
  try {
    await fs.promises.writeFile(path.join(temp, 'index.csn'), cds.compile.to.json(csn))
    const config = linter.configCopyFrom(cds.env)
    await fs.promises.writeFile(path.join(temp, '.cdsrc.json'), JSON.stringify(config, null, 2))
    return await tar.cz(temp)
  } finally {
    rimraf (temp)
  }
}

const push = async function (req) {
  let { extension, tag } = req.data
  if (!extension) req.reject(400, 'Missing extension')
  const sources = typeof extension === 'string' ? Buffer.from(extension, 'base64') : extension
  const { extCsn, bundles } = await _compileProject(sources, req)
  if (!extCsn) req.reject(400, 'Missing or bad extension')
  if (!tag) tag = null
  const tenant = req.tenant
  if (tenant) cds.context = { tenant }

  // remove current extension with tag
  if (tag) await DELETE.from('cds.xt.Extensions').where({ tag })

  // validation
  LOG.info(`validating extension '${tag}' ...`)
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  // REVISIT: Isn't that also done during activate?
  const csn = await mps.getCsn(tenant, Object.keys(cds.context.features || {}))
  try {
    cds.extend(csn).with(extCsn)
  } catch (err) {
    return req.reject(422, getCompilerError(err.messages))
  }

  const findings = linter.lint(extCsn, csn)
  if (findings.length > 0) {
    let message = `Validation for ${tag} failed with ${findings.length} finding(s):\n\n`
    message += findings.map(f => '  - ' + f.message).join('\n') + '\n'
    return req.reject(422, message)
  }

  // insert and activate extension
  const ID = cds.utils.uuid()
  await INSERT.into('cds.xt.Extensions').entries({
    ID,
    csn: JSON.stringify(extCsn),
    i18n: bundles ? JSON.stringify(bundles) : null,
    sources,
    activated: 'database',
    tag
  })

  LOG.info(`activating extension '${tag}' ...`)
  await activate(ID, null, tenant)
}

module.exports = { base, push, pull }
