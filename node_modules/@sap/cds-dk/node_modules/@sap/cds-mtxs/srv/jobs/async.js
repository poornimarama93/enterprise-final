// Helper functions to orchestrate an async API flow

const cds = require('@sap/cds/lib'), { uuid } = cds.utils
const LOG = cds.log('mtx')
const Jobs = 'cds.xt.Jobs'

class JobExecutor {

  static get _t0() {
    return cds.env.requires.multitenancy.t0 ?? 't0'
  }

  static reset(_conf) {
    // REVISIT:
    // - common config if this is also shared with extensibility-service?
    // - additional individual config for each service, overriding common config?
    const conf = _conf ?? cds.env.requires['cds.xt.SaasProvisioningService']?.jobs ?? {}
    const { queueSize, removalTimeout, parallelExecutions } = conf
    Object.assign(this, {
      _maxParallelJobs: parallelExecutions ?? 5,
      _maxQueueLength: queueSize ?? 1000,
      _queue: [],
      _jobs: new Map,
      _jobsRunning: new Map,
      _jobsFinished: new Map,
      _jobsFailed: new Map,
      _jobRemovalTimeout: removalTimeout ?? 1800000, // 30 min
      _jobRemovals: new Map,
    })
  }

  // TODO: test async = false for concurrency control for sync APIs
  static async submit(tenant, jobFunction, args = [], { context, /*async = true,*/ callback = null } = {}) {
    if (this._queue.length >= this._maxQueueLength) {
      cds.error(`Queue overflow. The max length is ${this._maxQueueLength}.`, { status: 429 })
    }
    args = Array.isArray(args) ? args : [args]
    const job = new Job(tenant, jobFunction, args, context, callback)
    const { jobID } = job
    LOG.info(`New job submitted with ID ${jobID}`)
    this._jobs.set(jobID, job)
    this._queue.push(jobID)

    await cds.tx({ tenant: this._t0 }, tx =>
      tx.run(INSERT.into(Jobs, { ID: jobID, tenant }))
    )
    //!async ? await this.nextTick((() => this._runNext(tenant))) : this.nextTick(() => this._runNext(tenant))
    _nextTick(() => this._runNext(tenant))
    context?._.res.status(202)
    context?._.res.set('Location', `${cds.server.url}/-/cds/saas-provisioning/jobs/${jobID}`)
    return { jobID }
  }

  static async getStatus(jobID, tenant, allowAll) {
    LOG.debug(`Get job status of ${jobID}`)
    let job = this._jobs.get(jobID)

    if (!job) {
        LOG.debug('Job not found in-memory, checking database')
        const where = allowAll ? { ID: jobID } : { ID: jobID, tenant }
        ;[job] = await cds.tx({ tenant: this._t0 }, tx =>
          tx.run(SELECT.from(Jobs, where, job => { job.status, job.result, job.timestamp })
        ))
        if ((job?.status ?? job?.STATUS) === EXECUTION_STATUS.FAILED) job.error = job.result
    }

    if (!job || (job?.tenant ?? job?.TENANT) !== tenant && !allowAll) {
      cds.error(`Job ${jobID} not found.`, { status: 404 })
    }

    return {
      processId: job.processId ?? job.ID,
      status: job.status ?? job.STATUS,
      result: job.result ?? job.RESULT,
      error: job.error ? job.error.toString() : undefined
    }
  }

  static async diagnose() {
    const jobs = (await cds.tx({ tenant: this._t0 }, tx =>
      tx.run(SELECT.from(Jobs, job => { job.ID }))
    )).map(({ID}) => ID)
    return {
      maxQueueLength: this._maxQueueLength,
      jobsWaiting: this._queue.map(jobID => ({ [this._jobs.get(jobID).tenant]: jobID })),
      jobsRunning: Object.fromEntries(this._jobsRunning),
      jobsFinished: Object.fromEntries(this._jobsFinished),
      jobsFailed: Object.fromEntries(this._jobsFailed),
      jobs
    }
  }

  static async _runNext() {
    let jobID, job, tenant
    let i = 0
    while (i <= this._queue.length) {
      jobID = this._queue[i], job = this._jobs.get(jobID), job && ({ tenant } = job)
      if (!this._jobsRunning.get(tenant)) break
      i++
    }
    if (!job) return

    this._queue.splice(i, 1)
    this._jobsRunning.set(tenant, jobID)
    LOG.debug(`Running job with ID ${jobID}`)
    await job.setJobStatus(EXECUTION_STATUS.RUNNING)

    let failed = false
    try {
      await job.run()
      LOG.debug(`Job ${jobID} succeeded`)
      if (!this._jobsFinished.get(tenant)) this._jobsFinished.set(tenant, [])
      this._jobsFinished.get(tenant).push(jobID)
    } catch (error) {
      LOG.error(`Job ${jobID} failed with error `, error)
      if (!this._jobsFailed.get(tenant)) this._jobsFailed.set(tenant, [])
      this._jobsFailed.get(tenant).push(jobID)
      failed = true
    } finally {
      this._jobsRunning.delete(tenant)
      _nextTick(() => this._runNext()) // Run next job from queue

      // Remove job after timeout
      const removeJob = async () => {
        this._jobs.delete(jobID)
        const jobs = failed ? this._jobsFailed : this._jobsFinished
        jobs.get(tenant)?.shift()
        if (jobs.get(tenant)?.length < 1) jobs.delete(tenant)

        await cds.tx({ tenant: this._t0 }, tx =>
          tx.run(DELETE.from(Jobs).where ({ID:{'=':jobID}}))
        )
        LOG.debug(`Removed job with ID ${jobID}`)
        this._jobRemovals.delete(jobID)
      }
      const jobRemoval = setTimeout(removeJob, this._jobRemovalTimeout)
      this._jobRemovals.set(jobID, { jobRemoval, removeJob })
    }
  }

  static async shutdown() {
    // Execute timeouts immediately
    for (const { jobRemoval, removeJob } of [...this._jobRemovals.values()]) {
      clearTimeout(jobRemoval)
      await removeJob() // eslint-disable-line no-await-in-loop
    }
    return this
  }
}

function _nextTick(callback) {
  return new Promise((resolve, reject) => {
    process.nextTick(() => {
      try {
        resolve(callback())
      } catch (error) {
        reject(error)
      }
    })
  })
}

const EXECUTION_STATUS = Object.freeze({
  QUEUED: 'queued',
  RUNNING: 'running',
  FINISHED: 'finished',
  FAILED: 'failed'
})

class Job {
  constructor(tenant, jobFunction, functionArgs, context, callback) {
    Object.assign(this, {
      jobID: uuid(),
      tenant, context, jobFunction, functionArgs, callback,
      status: EXECUTION_STATUS.QUEUED,
      result: undefined,
      processId: process.pid
    })
  }
  async setJobStatus(status) {
    this.status = status
    const t0 = cds.env.requires.multitenancy.t0 ?? 't0'
    await cds.tx({ tenant: t0 }, tx =>
      tx.run(UPDATE(Jobs, { ID: this.jobID, tenant: this.tenant }).with({ status }))
    )
  }
  async run() {
    if (this.context) cds.context = this.context
    try {
      this.result = await this.jobFunction(...this.functionArgs)
      await this.callback?.call(this, this, this.result)
      await this.setJobStatus(EXECUTION_STATUS.FINISHED)
    } catch (error) {
      this.result = error
      await this.callback?.call(this, this, this.error)
      await this.setJobStatus(EXECUTION_STATUS.FAILED)
      throw error
    }
    return this.result
  }
  get error() {
    return this.status === EXECUTION_STATUS.FAILED ? this.result : null
  }
}

JobExecutor.reset()

module.exports = {
  reset: JobExecutor.reset.bind(JobExecutor),
  submit: JobExecutor.submit.bind(JobExecutor),
  getStatus: JobExecutor.getStatus.bind(JobExecutor),
  diagnose: JobExecutor.diagnose.bind(JobExecutor),
  shutdown: JobExecutor.shutdown.bind(JobExecutor),
}
