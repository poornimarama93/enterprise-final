const cds = require('@sap/cds/lib'), {db} = cds.requires
module.exports = exports = { resources4, build }

if (db?.kind === 'hana') {

  // Check hana credentials to alert as early as possible
  if (!db.credentials) {
    cds.error('No HANA credentials found. Make sure the application is bound to a BTP Service Manager instance.')
  }

  exports.activated = 'HANA Database'

  // Add HANA-specific handlers to DeploymentService...
  cds.on ('served', () => {
    const { 'cds.xt.DeploymentService': ds } = cds.services
    const useOldIm = cds.env.requires['cds.xt.DeploymentService']?.['old-instance-manager']
    const hana = useOldIm ? require('./hana/inst-mgr') : require('./hana/srv-mgr')

    ds.on ('subscribe', req => {
      const { tenant:t, options: { _: params, csn } = {} } = req.data
      // REVISIT: in which scenarios do we need to get the tenant _before_ the subscription (e.g. shared service manager/domain concept)
      return prepareAndDeploy (t, hana.acquire(t, _imCreateParams(t, params)), params, csn ?? csn4(), csn ? undefined : resources4(t))
    })
    ds.on ('upgrade', async req => {
      const { tenant:t, options: { _: params } = {} } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t), resources4(t))
    })
    ds.on ('extend', async req => {
      const { tenant:t, options: { _: params } = {} } = req.data
      return prepareAndDeploy (t, hana.get(t), params, csn4(t)) // we don't support extensions with resources yet
    })
    ds.on ('deploy', async req => {
      const { tenant:t, options: { _: params, container, out } } = req.data
      return deploy (t, container, out, _hdiDeployParams(params))
    })
    ds.on ('unsubscribe', req => {
      const { tenant:t } = req.data
      if (cds.db) cds.db.disconnect(t) // Clean pool with active connections
      return hana.delete(t)
    })
    ds.on ('getTables', async req => {
      const { tenant:t } = req.data
      const { schema } = (t === _t0() ? await hana.acquire(t, _imCreateParams(t)) : await hana.get(t)).credentials
      return (await cds.tx({ tenant: t }, async tx =>
        await tx.run('SELECT TABLE_NAME FROM TABLES WHERE SCHEMA_NAME = ?', [schema])
      )).map(({ TABLE_NAME }) => TABLE_NAME)
    })
  })

}

function _t0() {
  return cds.env.requires.multitenancy.t0 ?? 't0'
}

function _imCreateParams(tenant, params = {}) {
  const paramsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.create ?? {}
  const paramsFromTenantOptions = cds.env.requires.multitenancy.for?.[tenant]?.hdi?.create ?? {}
  return { ...paramsFromEnv, ...paramsFromTenantOptions, ...params?.hdi?.create }
}
function _hdiDeployParams(params = {}) {
  const paramsFromEnv = cds.env.requires['cds.xt.DeploymentService']?.hdi?.deploy || {}
  return { ...paramsFromEnv, ...params?.hdi?.deploy }
}


const { fs, tar } = cds.utils
const LOG = cds.log('mtx')


async function csn4 (tenant) {
  const { 'cds.xt.ModelProviderService': mp } = cds.services
  return mp.getCsn ({ tenant, toggles: ['*'], activated: true }) // REVISIT: ['*'] should be the default?
}


async function resources4 (tenant) {

  const { 'cds.xt.ModelProviderService': mp } = cds.services
  const out = await fs.mkdirp ('gen',tenant)
  try {
    const rscs = await mp.getResources(true)
    await tar.xz(rscs).to(out)
    return out
  } catch (error) {
    // avoid that 404 bubbles up to response
    if (error.code) {
      error.code = 500
    }
    if (!error.message) {
      error.message = 'Could not get additional deployment resources'
    }
    cds.error(error)
  }
}


async function build (csn, tenant) {
  const out = await fs.mkdirp ('gen',tenant,'src','gen'), gen = []
  for (const [ddl,{file}] of cds.compile.to.hdbtable(csn)) {
    gen.push (fs.write(ddl) .to (out,file))
  }
  return Promise.all (gen)
}


/** Arguments _hana, _csn and _resources are promises awaited inline below */
async function prepareAndDeploy (tenant, _hana, params, _csn, ..._resources) {
  if (!cds.db) cds.db = cds.services.db = await cds.connect.to(db)

  const out = await fs.mkdirp ('gen',tenant)
  try {

    // Note: currently the hana files are created twice, first from getResources,
    // then from local compile -2 hana. This has to be adapted depending on if
    // the project is extended or not ideally the base hana files would have to
    // be filtered already when getting the resources

    // 1. unpack what comes from getResources()
    if (_resources) await Promise.all (_resources) //> has to finish before build

    // 2. run cds compile -2 hana with potentially extended model from getCsn()
    const csn = await _csn
    if (csn) await build (csn,tenant)

    if (tenant === _t0()) {
      await fs.write ({ "file_suffixes": {
        "csv":            { "plugin_name": "com.sap.hana.di.tabledata.source" },
        "hdbconstraint":  { "plugin_name": "com.sap.hana.di.constraint" },
        "hdbindex":       { "plugin_name": "com.sap.hana.di.index" },
        "hdbtable":       { "plugin_name": "com.sap.hana.di.table" },
        "hdbtabledata":   { "plugin_name": "com.sap.hana.di.tabledata" },
        "hdbview":        { "plugin_name": "com.sap.hana.di.view" }
      }}) .to (out,'src','gen','.hdiconfig')
    }

    // 3. hdi-deploy final build content
    const { 'cds.xt.DeploymentService': ds } = cds.services
    await ds.deploy({ tenant, options: { container: await _hana, out, _: params } })
  } finally {
    await fs.rimraf (out) // REVISIT: keep that for caching later on
  }
}

async function deploy (tenant, container, out, options) {
  try {
    const useOldIm = cds.env.requires['cds.xt.DeploymentService']?.['old-instance-manager']
    const hana = useOldIm ? require('./hana/inst-mgr') : require('./hana/srv-mgr')
    await hana.deploy (container, tenant, out, options)
    LOG.info(`Successfully finished HANA deployment for tenant ${tenant}`)
  } finally {
    await fs.rimraf (out)
  }
}
